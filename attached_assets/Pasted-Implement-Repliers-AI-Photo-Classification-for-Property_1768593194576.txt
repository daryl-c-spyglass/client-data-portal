Implement Repliers AI Photo Classification for Property Gallery
SCOPE
Implement "Browse by Room Type" tabs on Property Detail pages using Repliers imageInsights API data. Also enable AI-suggested photo selection for CMA reports based on classification and quality scores.

ENGINEERING TASKS
Task 1: Verify Repliers API returns imageInsights
bash# Check current listing detail fetch
grep -ri "imageInsights" --include="*.ts" --include="*.tsx" server/ client/

# Check the Repliers API call for listing detail
grep -ri "/listings/" --include="*.ts" server/routes/
typescript// In server route that fetches listing detail, ensure imageInsights is requested
// Repliers may require a specific parameter to include imageInsights

// Example: Check if we need to add a query param
const response = await fetch(
  `https://api.repliers.io/listings/${mlsNumber}?imageInsights=true`,
  { headers: { 'REPLIERS-API-KEY': process.env.REPLIERS_API_KEY } }
);
Task 2: Create normalized photo model with classifications
typescript// shared/types/photos.ts

export interface ClassifiedPhoto {
  url: string;                    // Full CDN URL from images[]
  filename: string;               // Original filename for matching
  roomType: string | null;        // From imageInsights.classification.imageOf
  confidence: number | null;      // From imageInsights.classification.prediction
  qualityScore?: number | null;   // If using quality scores feature
}

export interface PhotoGalleryData {
  allPhotos: ClassifiedPhoto[];
  roomTypes: string[];            // Distinct room types with photos
  hasClassifications: boolean;    // Whether imageInsights was available
}

// Room type display order (from Repliers supported list)
export const ROOM_TYPE_ORDER = [
  'Front of Structure',
  'Entrance Foyer',
  'Living Room',
  'Dining Room',
  'Kitchen',
  'Primary Bedroom',
  'Bedroom',
  'Primary Bathroom',
  'Bathroom',
  'Office',
  'Family Room',
  'Laundry',
  'Garage',
  'Backyard',
  'Pool',
  'Other'
];

// Minimum confidence threshold (Repliers recommends 0.90)
export const CLASSIFICATION_CONFIDENCE_THRESHOLD = 0.90;
Task 3: Build photo normalizer utility
typescript// server/utils/photoNormalizer.ts (or client-side)

import { ClassifiedPhoto, PhotoGalleryData, ROOM_TYPE_ORDER, CLASSIFICATION_CONFIDENCE_THRESHOLD } from '@/shared/types/photos';

interface RepliersListing {
  images: string[];
  imageInsights?: {
    images: Array<{
      image: string;
      classification?: {
        imageOf: string;
        prediction: number;
      };
    }>;
  };
}

export function normalizePhotos(listing: RepliersListing): PhotoGalleryData {
  const { images = [], imageInsights } = listing;
  
  // Build lookup from imageInsights
  const insightsMap = new Map<string, { roomType: string; confidence: number }>();
  
  if (imageInsights?.images) {
    imageInsights.images.forEach(insight => {
      if (insight.classification) {
        insightsMap.set(insight.image, {
          roomType: insight.classification.imageOf,
          confidence: insight.classification.prediction
        });
      }
    });
  }
  
  // Normalize all photos
  const allPhotos: ClassifiedPhoto[] = images.map(imageUrl => {
    // Extract filename from URL for matching
    const filename = imageUrl.split('/').pop() || imageUrl;
    const insight = insightsMap.get(filename);
    
    return {
      url: imageUrl,
      filename,
      roomType: insight?.roomType || null,
      confidence: insight?.confidence || null
    };
  });
  
  // Get distinct room types that meet confidence threshold
  const roomTypesSet = new Set<string>();
  allPhotos.forEach(photo => {
    if (photo.roomType && photo.confidence && photo.confidence >= CLASSIFICATION_CONFIDENCE_THRESHOLD) {
      roomTypesSet.add(photo.roomType);
    }
  });
  
  // Sort room types by preferred order
  const roomTypes = Array.from(roomTypesSet).sort((a, b) => {
    const indexA = ROOM_TYPE_ORDER.indexOf(a);
    const indexB = ROOM_TYPE_ORDER.indexOf(b);
    // Unknown types go to end
    return (indexA === -1 ? 999 : indexA) - (indexB === -1 ? 999 : indexB);
  });
  
  // Log stats for debugging
  console.log('[PhotoNormalizer] Stats:', {
    totalPhotos: images.length,
    hasImageInsights: !!imageInsights,
    classifiedPhotos: allPhotos.filter(p => p.roomType).length,
    highConfidencePhotos: allPhotos.filter(p => p.confidence && p.confidence >= CLASSIFICATION_CONFIDENCE_THRESHOLD).length,
    roomTypesFound: roomTypes.length
  });
  
  return {
    allPhotos,
    roomTypes,
    hasClassifications: !!imageInsights && insightsMap.size > 0
  };
}

// Get photos filtered by room type
export function getPhotosByRoom(
  photos: ClassifiedPhoto[], 
  roomType: string | 'all',
  includeUnclassified = false
): ClassifiedPhoto[] {
  if (roomType === 'all') {
    return photos;
  }
  
  return photos.filter(photo => {
    if (photo.roomType === roomType && photo.confidence && photo.confidence >= CLASSIFICATION_CONFIDENCE_THRESHOLD) {