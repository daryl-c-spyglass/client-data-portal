## Implement JWT Authentication for Vercel Serverless Deployment

Per Clawd's guidance, we need to replace session-based auth with JWT for Vercel serverless compatibility.

### Task 1: Create new file `server/jwt.ts`
```typescript
import jwt, { JwtPayload } from "jsonwebtoken";
import type { Request, Response, NextFunction } from "express";
import type { User } from "@shared/schema";
import { storage } from "./storage";

interface JWTUserPayload {
  id: string;
  email: string;
  isAdmin: string | null;
  isSuperAdmin: boolean | null;
  iat: number;
  exp: number;
}

// Get JWT secret, with fallback for development
function getJWTSecret(): string {
  const secret = process.env.JWT_SECRET;
  if (!secret) {
    if (process.env.NODE_ENV === 'production') {
      throw new Error('JWT_SECRET environment variable is required in production');
    }
    console.warn('⚠️ Using fallback JWT secret for development. Set JWT_SECRET environment variable.');
    return 'dev-jwt-secret-change-in-production';
  }
  return secret;
}

/**
 * Generate a JWT token for a user
 */
export function generateJWT(user: User): string {
  const payload: Omit<JWTUserPayload, 'iat' | 'exp'> = {
    id: user.id,
    email: user.email,
    isAdmin: user.isAdmin,
    isSuperAdmin: user.isSuperAdmin,
  };

  return jwt.sign(payload, getJWTSecret(), {
    expiresIn: '7d',
    algorithm: 'HS256',
  });
}

/**
 * Verify and decode a JWT token
 */
export function verifyJWT(token: string): JWTUserPayload | null {
  try {
    const decoded = jwt.verify(token, getJWTSecret(), { algorithms: ['HS256'] }) as JwtPayload;
    
    if (typeof decoded === 'object' && decoded.id && decoded.email) {
      return decoded as JWTUserPayload;
    }
    
    console.warn('[JWT] Token has invalid structure');
    return null;
  } catch (error) {
    if (error && typeof error === 'object' && 'name' in error) {
      if (error.name === 'TokenExpiredError') {
        console.log('[JWT] Token expired');
      } else if (error.name === 'JsonWebTokenError') {
        console.log('[JWT] Token invalid:', (error as any).message);
      }
    }
    return null;
  }
}

/**
 * Extract JWT token from request (cookie or Authorization header)
 */
function extractTokenFromRequest(req: Request): string | null {
  const cookieToken = req.cookies?.['auth-token'];
  if (cookieToken) {
    return cookieToken;
  }

  const authHeader = req.headers.authorization;
  if (authHeader && authHeader.startsWith('Bearer ')) {
    return authHeader.substring(7);
  }

  return null;
}

/**
 * Set secure JWT cookie
 */
export function setJWTCookie(res: Response, token: string): void {
  const isProduction = process.env.NODE_ENV === 'production';
  
  res.cookie('auth-token', token, {
    httpOnly: true,
    secure: isProduction,
    sameSite: isProduction ? 'none' : 'lax',
    maxAge: 1000 * 60 * 60 * 24 * 7, // 7 days
    path: '/',
  });
}

/**
 * Clear JWT cookie
 */
export function clearJWTCookie(res: Response): void {
  res.clearCookie('auth-token', {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: process.env.NODE_ENV === 'production' ? 'none' : 'lax',
    path: '/',
  });
}

/**
 * JWT Authentication middleware - replaces session-based requireAuth
 */
export function requireJWTAuth(req: Request, res: Response, next: NextFunction): void {
  const token = extractTokenFromRequest(req);
  
  if (!token) {
    res.status(401).json({ error: "Authentication required" });
    return;
  }

  const payload = verifyJWT(token);
  if (!payload) {
    res.status(401).json({ error: "Invalid or expired token" });
    return;
  }

  (req as any).user = {
    id: payload.id,
    email: payload.email,
    isAdmin: payload.isAdmin,
    isSuperAdmin: payload.isSuperAdmin,
  };

  (req as any).isAuthenticated = () => true;
  next();
}
```

### Task 2: Update `package.json` - add to dependencies section:
```json
"jsonwebtoken": "^9.0.2",
"@types/jsonwebtoken": "^9.0.5",
"jose": "^5.2.0"
```

### Task 3: Update `server/app.ts`

REMOVE these imports:
```typescript
import session from "express-session";
import ConnectPgSimple from "connect-pg-simple";
import { Pool } from "@neondatabase/serverless";
```

REMOVE the entire session setup block (PgSession, sessionStore, app.use(session(...)))

REMOVE this line:
```typescript
app.use(passport.session());
```

KEEP this line:
```typescript
app.use(passport.initialize());
```

### Task 4: Update `server/auth.ts`

ADD this import at the top:
```typescript
import { generateJWT, setJWTCookie, clearJWTCookie } from "./jwt";
```

REMOVE passport.serializeUser and passport.deserializeUser blocks entirely.

ADD instead:
```typescript
// JWT-based auth - no session serialization needed
// User info is stored in JWT tokens, not server sessions
```

UPDATE the Google OAuth callback - find `return done(null, user);` and REPLACE with:
```typescript
// Generate JWT token and set cookie
const token = generateJWT(user);
return done(null, { user, token });
```

UPDATE the logout route - REPLACE with:
```typescript
app.post("/api/auth/logout", (req, res) => {
  clearJWTCookie(res);
  res.json({ success: true });
});
```

UPDATE the Google OAuth callback route handler to set JWT cookie:
```typescript
app.get("/auth/google/callback", passport.authenticate("google"), (req, res) => {
  const authResult = req.user as any;
  if (authResult?.token) {
    setJWTCookie(res, authResult.token);
  }
  
  // existing redirect logic stays the same
});
```

### Task 5: Run npm install

After making changes, run:
```bash
npm install
```

### Task 6: Add JWT_SECRET to Vercel Environment Variables

In Vercel dashboard, add:
- `JWT_SECRET` = (generate a secure 64-character random string)

### Commit and push with message: "Implement JWT authentication for Vercel serverless"